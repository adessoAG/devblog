<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<documents>
    <document uid="38d7fc145b8d3dfe02d36cefe0d6d63d">
        <field name="title"><![CDATA[GitHub Actions im Java Projekt]]></field>
        <field name="subline"><![CDATA[]]></field>
        <field name="teaser"><![CDATA[<p>GitHub-Actions ist das hauseigene Tool der Open-Source Plattform, um Prozesse in einem Softwareprojekt zu automatisieren.
In diesem Blogpost wirst du methodisch lernen, wie ein Java Projekt mit GitHub Actions ausgestattet wird.
Die Schwerpunkte sind das Bauen und Testen des Projekts. 
Zudem das Deployen von Artefakten in Bezug auf Actions und die Anbindung von Cloud Services wie z.B SonarCloud.
Abschließend noch die Erzeugung eines Releases.</p>

]]></field>
        <field name="language_multi_keyword"><![CDATA[de]]></field>
        <field name="content_type_multi_keyword"><![CDATA[blog]]></field>
        <field name="mime_type_multi_keyword"><![CDATA[text/html]]></field>
        <field name="category_multi_keyword"><![CDATA[Softwareentwicklung]]></field>
        <field name="tag_multi_keyword"><![CDATA[GitHub]]></field>
        <field name="tag_multi_keyword"><![CDATA[Gradle]]></field>
        <field name="tag_multi_keyword"><![CDATA[Spring Boot]]></field>
        <field name="tag_multi_keyword"><![CDATA[Java]]></field>
        <field name="date_date"><![CDATA[2020-03-25T09:38:00+01:00]]></field>
        <field name="date_l"><![CDATA[1585125480000]]></field>
        <field name="change_date"><![CDATA[1592177400000]]></field>
        <!--Picture-->
        <!-- Not in use at the moment-->
        <!--Author Information-->
        <field name="author_first_name"><![CDATA[Cem]]></field>
        <field name="author_last_name"><![CDATA[Caylak]]></field>
        <field name="author_id"><![CDATA[ccaylak]]></field>
        <field name="author_picture_stored_only"><![CDATA[http://localhost:4000/assets/images/avatars/ccaylak.png]]></field>
        <!--Postcontent-->
        <field name="headlines"><![CDATA[GitHub Actions im Java Projekt]]></field>
        <field name="display_content"><![CDATA[<div class="i2-intro p-t-1">
            <p>GitHub-Actions ist das hauseigene Tool der Open-Source Plattform, um Prozesse in einem Softwareprojekt zu automatisieren.
In diesem Blogpost wirst du methodisch lernen, wie ein Java Projekt mit GitHub Actions ausgestattet wird.
Die Schwerpunkte sind das Bauen und Testen des Projekts. 
Zudem das Deployen von Artefakten in Bezug auf Actions und die Anbindung von Cloud Services wie z.B SonarCloud.
Abschließend noch die Erzeugung eines Releases.</p>

</div>]]></field>
        <field name="content"><![CDATA[<div class="adesso-text-formate">
<div class="row p-t-2">
<div class="adesso-container">
<div class="col-xl-8 adesso-center p-b-1 p-l-0 p-r-0">
    <p>GitHub-Actions ist das hauseigene Tool der Open-Source Plattform, um Prozesse in einem Softwareprojekt zu automatisieren.
In diesem Blogpost wirst du methodisch lernen, wie ein Java Projekt mit GitHub Actions ausgestattet wird.
Die Schwerpunkte sind das Bauen und Testen des Projekts. 
Zudem das Deployen von Artefakten in Bezug auf Actions und die Anbindung von Cloud Services wie z.B SonarCloud.
Abschließend noch die Erzeugung eines Releases.</p>

<h4 id="was-ist-github-actions">Was ist GitHub Actions?</h4>
<p>Diese API wird für öffentliche GitHub Projekte zur Verfügung gestellt.
Dadurch können Workflowschritte definiert werden, die durch GitHub Events, wie einem <strong>Pull Request</strong> ausgelöst werden.</p>

<p>Die Workflowschritte sind demnach vom Code losgelöst, sowie ein Teil des Repositorys. 
Die eigenen Software Development Practices können erstellt, geteilt, wiederverwendet und geforked werden.</p>

<p>Danach übernimmt GitHub die Ausführung und gibt dem Entwickler ein umfangreiches Feedback.
Außerdem wird eine plattformunabhängige Automatisierung der Build-, Test-, und Deployschritte ermöglicht.
Die Ausführung kann unter den gängigen Betriebssystemen Windows, Linux und macOS durchgeführt werden.
Auch kannst du festlegen, ob die Workflows in einem Container oder in einer virtuellen Maschine ausgeführt werden sollen.</p>

<h5 id="erzeugung-des-java-projekts">Erzeugung des Java Projekts</h5>
<p>Als beispielhaftes Java Projekt dient eine Spring Boot Anwendung, die mit dem <a href="https://start.spring.io/">Spring Boot Starter</a> erstellt wurde.
Das Projekt ist mit Java 11 und Gradle ausgestattet.</p>

<h6 id="gradle-projekt-bauen-und-testen">Gradle Projekt bauen und testen</h6>
<p>Um Actions in der Oberfläche von GitHub aufzurufen, gibt es im Repository den Reiter “Action”.</p>

<p><img src="/assets/images/posts/github-actions/actions-tab.JPG" alt="Bild vom Actions Reiter" /></p>

<p>Angekommen in den Actions, kriegen wir vom intuitiven System eine Menge bereits definierter Actions, die <strong>out of the box</strong> sind.
Namhafte Sprachen und Frameworks werden unterstützt.
Zum Herumexperimentieren stellt GitHub dem Benutzer eine Starter-Action zur Verfügung.</p>

<p>In diesem werden alle Punkte einer YML-Datei grob angeschnitten und erklärt, wofür diese benötigt werden.
Es gibt bereits zahlreiche Actions von GitHub selbst und der Open-Source Community, beispielsweise eine um ein Gradle Projekt bauen und testen zu lassen.
Diese Action wird im späteren Verlauf dieses Blogposts als Grundlage für die anderen Tasks des Workflows wiederverwendet.</p>

<p>Im Folgenden wird der Codeblock der Action genauer betrachtet.
Weiterhin werden die einzelnen Werte genauer erklärt.</p>
<pre><code class="language-yaml">name: Spring Boot

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up JDK 11
      uses: actions/setup-java@v1
      with:
        java-version: 11
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
    - name: Build with Gradle
      run: ./gradlew build
</code></pre>
<p>Das Schlüsselwort <code>name</code> gibt an, wie die Action in der Ausführung bzw. auf GitHub heißen wird.
Danach folgt <code>on</code>, was festlegt, auf welche GitHub-Events die Action reagieren soll.
In der Array-Schreibweise folgen die Repositorys bzw. Branches, für die diese Actions gelten sollen.
Dementsprechend können Komma separiert mehrere Branches angegeben werden.</p>

<p>Für unser Projekt wird auf die Event-Typen <code>push</code> und <code>pull_request</code> reagiert.
Welche weiteren Event-Typen es gibt, kann in der <a href="https://help.github.com/en/actions/reference/events-that-trigger-workflows">Dokumentation</a> nachgesehen werden.</p>

<p>Anschließend beginnt der Workflow, der aus einem oder mehreren Workflowschritten besteht.
Je nach Konfiguration können diese sequenziell oder parallel abgearbeitet werden.</p>

<p>Nun folgen die einzelnen Jobs, wobei <code>build</code> den Namen des einzigen Workflowschritt angibt.
Zusätzlich wird mit <code>runs-on</code> angegeben, auf welcher Ausführungsumgebung dieser ausgeführt werden soll.</p>

<p>Mit <code>steps</code> wird eine Folge von Schritten definiert, die für diesen Job benötigt werden.
Als nächstes wird das Repository mit Befehl <code>- uses: actions/checkout@v2</code> über Git ausgecheckt, damit es für den Job benutzt werden kann.</p>

<p>Nachdem das Repository ausgecheckt wurde, wird mit den nächsten drei Zeilen das Java SDK gesetzt.
Für dieses Projekt wurde Java 11 verwendet, weshalb die Zahl bei <code>java-version</code> auf <strong>11</strong> wurde.</p>

<p>Der Job braucht wiederum Rechte, um den danach folgenden Befehl ausführen zu können, daher werden diese mit <code>run: chmod +x gradlew</code> eingeholt.</p>

<p>Im letzten Schritt der Action wird das Gradle-Projekt mit <code>./gradlew build</code> gebaut und getestet.</p>

<p><img src="/assets/images/posts/github-actions/gradle-build-result.JPG" alt="Bild des Ergebnisses des Gradle Builds" /></p>

<p>In der ersten Zeile der Abbildung steht der Name des Commits und ob dieser erfolgreich war oder fehlgeschlagen ist.
Eine Zeile darunter ist der Branch, die Commit-Nummer und die Commit-Message angegeben.
Anschließend folgt der Name der Actions und darunter werden die einzelnen Jobs aufgelistet.
Zu guter Letzt gibt es rechts einen genauen Ablauf der einzelnen Steps.
Diese besitzen eine Zeitangabe und können bei Bedarf aufgeklappt und näher betrachtet werden.</p>

<h6 id="sonarcloud-anbindung">SonarCloud Anbindung</h6>
<p>Ein weiterer Aspekt dieses Blogposts ist die SonarCloud Anbindung mittels Actions im Java Projekt.
Für unseren Anwendungsfall benötigen wir das SonarQube und Jacoco für Gradle. 
Diese fügen wir dem Projekt hinzu, indem wir folgende Zeilen zum Punkt plugins der build.gradle eintragen.</p>

<pre><code class="language-gradle">plugins {
	id "org.sonarqube" version "3.0"
	id 'jacoco'
}
</code></pre>

<p>Ferner muss die Version von Jacoco und dass ein Test-Report im XML format generiert werden soll angegeben.</p>

<pre><code class="language-gradle">jacoco {
	toolVersion = "0.8.5"
}

jacocoTestReport {
	reports {
		xml.enabled true
	}
}
</code></pre>

<p>Als Letztes muss SonarCloud in den gradle.properties konfiguriert werden.
Hierzu wird die Url, Organisation und der Project-Key eingeschrieben.</p>

<pre><code class="language-gradle">systemProp.sonar.host.url=https://sonarcloud.io/
systemProp.sonar.organization=adesso-ag
systemProp.sonar.projectKey=adessoAG_github-actions-demo
</code></pre>
<p>Auf SonarCloud muss du noch über den Pfad <em>My Account-&gt;Security-&gt;Tokens</em> einen projektspezifischen Token generieren.
Dieser wird als Secret im GitHub Repository angelegt, damit er nicht von außen sichtbar ist.</p>

<p>Wir erstellen einen neuen Job namens <code>sonarcloud</code>.</p>

<p>Alles bereits konfigurierte vom o.g Kapitel wird wieder benötigt.
Damit ist das Setzen der Ausführungsumgebung, das Auschecken von Git, das Aufsetzten vom SDK und die Gradle Rechte Einholung gemeint.</p>
<pre><code class="language-yaml">  sonarcloud:

    runs-on: ubuntu-latest

    steps:
    
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0
    - name: Set up JDK 11
      uses: actions/setup-java@v1
      with:
        java-version: 11
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
</code></pre>

<p>Folgend wird der zuvor erstellte Sonar Token und von Actions selbst generierter GitHub Token als Umgebungsvariable angegeben.
Umgebungsvariablen bzw. Enviroment variables werden unter <code>env</code> angegeben.
Hinterher wird <code>gradlew test jacocoTestReport sonarqube -Dsonar.login=$SONAR_TOKEN</code> im <code>run</code> ausgeführt.
Folgende Zeilen Code ergänzen den <code>sonarcloud</code> Workflow:</p>
<pre><code class="language-yaml">- name: SonarQube and Jacoco
      run: ./gradlew test jacocoTestReport sonarqube -Dsonar.login=$SONAR_TOKEN      
      env: 
        SONAR_TOKEN: $
        GITHUB_TOKEN: $
</code></pre>

<h6 id="artefakte-hochladen">Artefakte hochladen</h6>

<p>Die Test-Coverage eines Projekts wird mit Jacoco prima gehandelt, der Entwickler würde den entsprechenden HTML-Report gerne als Artefakt hochladen.
Außerdem erstellt Gradle selbst auch einen Test-Report im HTML-Format, der ebenfalls als Artefakt hochgeladen werden soll.
Dies wird mit den folgenden zwei Workflowschritten realisiert.</p>

<pre><code class="language-yaml"> - name: Archive code coverage results
      uses: actions/upload-artifact@v1
      with:
        name: Jacoco Test-Report
        path: build/reports/jacoco/test/html
  - name: Archive test results
      uses: actions/upload-artifact@v1
      with:
        name: Gradle Test report
        path: build/reports/tests/test
</code></pre>

<p>Für das Hochladen von Artefakten wird  <code>actions/upload-artifact@v1</code> verwendet.
Dem Workflowschritten wird ein Name unter <code>name</code> gegeben und ein Output-Pfad der zur hochladenenden Datei bzw. Dateien.
Da CSS Dateien oder andere Abhängigkeiten vom HTML-Output vorhanden sein können, werden ganze Pfade und keine einzelnen Dateien übergeben.</p>

<h6 id="release-erzeugen">Release erzeugen</h6>
<p>Als Letztes werden wir automatisiert einen Release erzeugen lassen.
Hierfür durchsuchen wir wieder den Marketplace nach einer passenden Action.
Es gibt bereits <a href="https://github.com/actions/create-release">Create A Release</a>, das verifiziert und von GitHub selbst erstellt wurde.
Nach näherer Betrachtung des vorgegeben Beispiels, kann es problemlos angewandt werden.</p>

<p>Hierfür wird ein neuer Workflow erstellt, der nur den Job der Release-Erstellung beinhaltet.
Ein eigener Workflow ist sinnvoll, da er neben dem Event-Typen auch auf den Tag eines <strong>Push</strong> oder <strong>Pullrequests</strong> achten soll.</p>
<pre><code class="language-yaml">on:
  push:
    # Sequence of patterns matched against refs/tags
    tags:
      - 'v*' # Push events to matching v*, i.e. v1.0, v20.15.10

name: Create Release

jobs:
  build:
    name: Create Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@master
      - name: Create Release
        id: create_release
        uses: actions/create-release@latest
        env:
          GITHUB_TOKEN: $ # This token is provided by Actions, you do not need to create your own token
        with:
          tag_name: $
          release_name: Release $
          body: |
            Changes in this Release
            - First Change
            - Second Change
          draft: false
          prerelease: false
</code></pre>
<p>Als Erstes muss wieder der Event-Typ angegeben werden.
Optional kann auch ein Branch gegeben werden.
Wenn keiner angegeben ist, gilt diese Actions für alle.</p>

<p>Anschließend wird angeordnet, auf welche Tags reagiert werden soll,
<code>v*</code>, bedeutet das alles was mit dem Buchstaben v startet einen Release erzeugt.
Dadurch wird die semantische Versionierung (v1.0, v1.0.0 usw) unterstützt.
<em>Wie Patterns auf GitHub gehandhabt werden, kannst du <a href="https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet">hier</a> nachschauen.</em> 
Wieder wird der Runner und der bekannte Step ausgeführt um das Repository zu bekommen.</p>

<p>Danach wird die Action zum Release erzeugen aufgerufen.
Diese benötigt eine Umgebungsvariable, die sich GitHub selbst erstellt. 
Dementsprechend muss hier kein Token selbst erzeugt werden.
Den Tag-Namen und den Release-Name setzt bzw. holt sich GitHub selbst vom Commit.
Im Body steht dann der textuelle Inhalt des Releases.</p>

<p>Der Draft gibt an, ob der Release published <em>(true)</em> oder unpublished <em>(false)</em> sein soll.
Der Wert des Prerelease Attributs legt fest, ob es sich um einen vollwertigen, eigenständigen Release handelt oder einen Prerelease.
Anschließend sieht das Release wie folgt aus.</p>

<p><img src="/assets/images/posts/github-actions/release.JPG" alt="Bild des Releases" /></p>

<h5 id="mein-fazit">Mein Fazit</h5>
<p>GitHub-Actions ist ein muss bei Anwendungen, die sowieso auf GitHub verwaltet wurden, insbesondere im Open Source Bereich.</p>

<p>Einige der größten Vorteile sind, dass es eine sehr detaillierte Dokumentation gibt und es einfach zu verstehen ist.
Des Weiteren gibt es einen <a href="https://github.com/marketplace?type=actions">Marketplace</a>, zu dem die Community beitragen kann.</p>

<p>Der Funktionsumfang ist gigantisch und jeder, dessen Interesse erweckt wurde, sollte sich die Dokumentation genauer anschauen.
Denn dieser Blogpost dient lediglich als Guide, um zu zeigen wie einfach CI/CD Prozesse mit Actions realisiert werden können.</p>

<p>Außerdem ist es schön, dass Actions direkt in der Oberfläche von GitHub erstellt werden können.
Die Dateien werden anschließend mit ins Repository gepusht, aber der Support ist dank der Oberflächte angenehmer.</p>

</div>
</div>
</div>
</div>]]></field>
    </document>
</documents>
